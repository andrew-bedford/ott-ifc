metavar variable, x ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum }}
metavar channel, c ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum }}
metavar integer, n ::= {{ coq nat }} {{ lex  numeral }}
indexvar index, i, j ::= {{ coq nat }}

grammar
arith_expr, a :: ae_ ::=
    | x                                 ::  :: variable
    | n                                 ::  :: int
    | a1 + a2                           ::  :: addition
    | a1 * a2                           ::  :: multiplication

bool_expr, b :: be_ ::=
    | true                              ::  :: true
    | false                             ::  :: false
    | a1 < a2                           ::  :: less_than

commands, cmd :: cmd_ ::=
    | stop                              ::  :: stop
    | skip                              ::  :: skip
    | x := a                            ::  :: assignment
    | cmd1 ; cmd2                           ::  :: sequence
    | if b then cmd1 else cmd2 end          ::  :: if
    | while b do cmd end                  ::  :: while
    | read x from c                     ::  :: read
    | write x to c                      ::  :: write

memory, m :: memory_ ::=
   | empty                              ::  :: empty
   | m [ x |-> n ]                      ::  :: cell

formula :: formula_ ::=
   | judgement                          ::  :: judgement
   | m ( x ) = n                        ::  :: lookup
   | n1 + n2 = n3                       ::  :: addition
   | n1 * n2 = n3                       ::  :: multiplication
   | n1 < n2 = true                     ::  :: lt_true
   | n1 < n2 = false                    ::  :: lt_false

terminals :: terminals_ ::=
  |  ->                                ::   :: arrow      {{ tex \rightarrow }}
  | |-                                 ::   :: turnstile  {{ tex \vdash }}
  | |->                                ::   :: mapsto     {{ tex \mapsto }}
  | -->                                ::   :: red        {{ tex \longrightarrow }}
  | ||                                 ::   :: bigstep    {{ tex \Downarrow }}
  | '{'                                ::   :: leftbrace  {{ tex \{ }}
  | '}'                                ::   :: rightbrace {{ tex \} }}
  | '<'                                ::   :: leftangle {{ tex \langle}}
  | '>'                                ::   :: rightangle {{ tex \rangle}}

%----------------------------------------------------------------%
%                    BIG-STEP SEMANTICS                        %
%----------------------------------------------------------------%
defns
Jop :: '' ::= 

%%%%%%%%%%%%%%%%%%%%%%%%%%% Arithmetic Expressions %%%%%%%%%%%%%%%%%%%%%%%%%%%
defn 
< a , m > || < a' , m' > :: :: arith_ops :: 'aexp_' by

----------------- :: int_constant
<n, m> || <n, m>

m(x) = n
----------------- :: lookup
<x, m> || <n, m>

%%% Addition %%%
<a1, m> || <n1, m>
<a2, m> || <n2, m>
n1 + n2 = n3
------------------------------ :: add
<a1 + a2, m> || <n3, m>


%%% Multiplication %%%
<a1, m> || <n1, m>
<a2, m> || <n2, m>
n1 * n2 = n3
------------------------------ :: mult
<a1 * a2, m> || <n3, m>

%%%%%%%%%%%%%%%%%%%%%%%%%%% Boolean Expressions %%%%%%%%%%%%%%%%%%%%%%%%%%%
defn 
< b , m > || < b' , m' > :: :: bool_ops :: 'bexp_' by

<a1, m> || <n1, m>
<a2, m> || <n2, m>
n1 < n2 = true
------------------------------ :: lt_true
<a1 < a2, m> || <true, m>

<a1, m> || <n1, m>
<a2, m> || <n2, m>
n1 < n2 = false
------------------------------ :: lt_false
<a1 < a2, m> || <false, m>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Commands %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
defn 
< cmd , m > || < cmd' , m' > :: :: cmd_ops :: 'cmd_' by

%%% Assignment %%%
<a, m> || <n, m>
----------------------------- :: assign
<x := a, m> || <stop, m[x |-> n]>

%%% Sequence %%%
<cmd1, m> || <stop, m'>
<cmd2, m'> || <stop, m''>
-------------------------------- :: sequence
<cmd1 ; cmd2, m> || <stop, m''>

%%% If %%%
<b, m> || <true, m>
<cmd1, m> || <stop, m'>
---------------------------------------------------------------- :: if_true
<if b then cmd1 else cmd2 end, m> || <stop, m'>

<b, m> || <false, m>
<cmd2, m> || <stop, m'>
---------------------------------------------------------------- :: if_false
<if b then cmd1 else cmd2 end, m> || <stop, m'>

%%% While %%%
<b, m> || <true, m>
<cmd, m> || <stop, m'>
<while b do cmd end, m'> || <stop, m''>
--------------------------------------------------------------------------- :: while_true
<while b do cmd end, m> || <stop, m''>

<b, m> || <false, m>
--------------------------------------------------------------------------- :: while_false
<while b do cmd end, m> || <stop, m>

m(c) = n
--------------------------------------------------------------------------- :: read
<read x from c, m> || <stop, m[x |-> n]>

m(x) = n
--------------------------------------------------------------------------- :: write
<write x to c, m> || <stop, m[c |-> n]>
